<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>信息咨询</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    .demo {
      position: fixed;
      left: 50%;
      top: 30%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>

<body>

  <div id="hello-vue" class="demo">
    <div v-for="(v, i) in mixinList" :key="i" v-show="acitveIndex === i">
      <h2>({{i+1}}/{{mixinList.length}})</h2>
      <p>问题：{{v.title}}</p>
      <p v-show="showAnswerList.indexOf(i) > -1" v-html="`答案：${v.answer}`"></p>
    </div>
    <textarea type="text" v-model="answer" style="width: 500px;height: 200px;display: inline-block;"></textarea>
    <div style="margin: 50px 0;"></div>
    <div style="display: flex;justify-content: space-between;align-items: center;">

      <div>

        <button @click="acitveIndex--" v-show="acitveIndex !== 0">上一题</button>
        <button @click="showAnswerList.push(acitveIndex)"
          v-show="showAnswerList.indexOf(acitveIndex) === -1">查看答案</button>
        <button @click="showAnswerList= showAnswerList.filter((v) => {return acitveIndex !== v})"
          v-show="showAnswerList.indexOf(acitveIndex) !== -1">隐藏答案</button>
        <button @click="acitveIndex++" v-show="acitveIndex !== (mixinList.length - 1)">下一题</button>
      </div>
      <div>
        <button @click="mixinListFn">乱序</button>
      </div>
    </div>
  </div>

  <script>

    const HelloVueApp = {
      data() {
        return {
          acitveIndex: 0,
          answer: '',
          showAnswerList: [],
          mixinList: [],
          list: [
            {
              title: '信息的概念',
              answer: `
              <br/>
              1.信息是对客观事物的反映。
              <br/>
               2.本质上看信息是对社会、自然界的事物特征、现象、本质及规律的描述。`
            },
            {
              title: '信息与数据的关系',
              answer: `
              <br/>
              1.数据是可以记录、传递和识别的符号，是信息的载体。
              <br/>
2.信息是数据的加工结果，是数据的含义。

              `
            },
            {
              title: '信息的特点及性质',
              answer: `<br/>
              特点： <br/>
1.信息的存在不以主体存在而转移。<br/>
2.信息在主观上是可以接受和利用的，并指导人们的行为。<br/>
性质：<br/>
1.客观性<br/>
2.时效性<br/>
3.价值型<br/>
4.可传播性<br/>
5.可扩散性<br/>
6.等级性<br/>
`
            },
            {
              title: '系统的概念',
              answer: `<br/>
              为了达到某种目的，对一群单元进行有规律的安排，使其成为一个相关联的整体。<br/>
              系统依赖于环境，不能孤立。<br/>
              系统和环境相互影响相互交流。<br/>
`
            },
            {
              title: '系统的分类',
              answer: `<br/>
                物理系统和抽象系统
<br/> 
`
            },
            {
              title: '系统的三个独立的特征',
              answer: `<br/>
              1、有元素及结构。 2、有明确的目标 3.有确定的边界。

               <br/> 
`
            },
            {
              title: '系统的一般模型',
              answer: `<br/>输入、处理、输出。
               <br/> 
`
            },
            {
              title: '信息系统的应用',
              answer: `<br/>
              1.CAD计算机辅助设计、CAM计算机辅助管理 <br/> 
2.CIS 计算机信息系统 <br/> 
3.DPS 数据处理系统 <br/> 
4.MIS 辅助管理系统 <br/> 
5.DSS 决策支持系统 <br/> 
6.ERP 企业资源计划 <br/> 

              
`
            },
            {
              title: '信息系统的发展趋势',
              answer: `<br/>
              1.系统开发 ----- 系统集成<br/> 
2.程序为中心 ---- 以信息内容为中心或者以用户为中心<br/> 
3.孤立的集中控制式系统 ----- 协同开放的分布式系统<br/> 
4.外在表现从固定不变的系统----用户可自定义的界面 ---- 适应性的用户界面<br/> 

               
`
            },
            {
              title: '信息系统工程的概念',
              answer: `<br/>信息系统是用系统工程的原理、方法来指导信息系统工程建设与管理的一门工程技术学科。

               <br/> 
`
            },
            {
              title: '信息系统的特点',
              answer: `<br/>
              1.管理上的科学性<br/> 
2.技术应用上的综合性<br/> 
3.研究方法的整体性    <br/> 
               <br/> 
`
            },
            {
              title: '信息系统的研究方法',
              answer: `<br/>1.技术方法 <br/> 
2.社会技术系统方法 <br/> 
3.行为方法 <br/> 

               <br/> 
`
            },
            {
              title: '信息系统工程的研究范围',
              answer: `<br/>
              1.信息系统建设与管理的概念、方法、评价、规划、工具和标准等一系列相关问题。 <br/> 
2.发展和研究实现信息化建设的工程方法。 <br/> 
3.数据库及应用软件的设计与实现 <br/> 
4.总体数据规划，设计数据的稳定性和共享性的一致性 <br/> 
5.系统集成的原则、方法、技术、工具和有关的标准及规范。 <br/> 

              
`
            },
            {
              title: '七种信息系统开发方法',
              answer: `<br/>
              1.生命周期方法： 强调结构化分析结构化设计。将生命周期定义为若干阶段，自上向下逐步开发。 <br/> 
2.原型法： 初期快速构建原型,后期对原型系统逐步求精，不断完善。 <br/> 
3.结构化方法：把开发分为多个阶段，每个阶段有明确的任务及目标。达到目标后开始下一阶段，否则返回。可以自上而下也能从底往上。 <br/> 
4.构件法 <br/> 
5.面向对象方法 <br/> 
6.面向服务方法 <br/> 
7.敏捷开发方法 <br/> 

              
`
            },
            {
              title: '生命周期法（三个周期-九个阶段',
              answer: `<br/>
              1.系统定义 <br/> 
1.1 问题定义 <br/> 
1.2 可行性研究（明确任务、调查环境、提出方案、可行性分析） <br/> 
1.3 需求分析（解决做什么的问题，调查研究、数据分析、功能分析、系统定义） <br/> 
2.系统设计  <br/> 
2.1 总体设计 <br/> 
2.2 详细设计 <br/> 
2.3 编码及单元测试 <br/> 
2.4 综合测试 <br/> 
3.系统实施与维护（解决具体做的问题） <br/> 
3.1 系统实施 <br/> 
3.2 系统维护 <br/>  
`
            },
            {
              title: '瀑布模型的概念',
              answer: `<br/>也称为生命周期模型或线性顺序模型,是一种系统化的、线性的开发方法
               <br/> 
`
            },
            {
              title: '2.瀑布模型的两个过程',
              answer: `<br/>2.1 开发过程：严格的下导式过程，各个阶段具有顺序性和依赖性，前一阶段的输出是下一阶段的输入，每个阶段工程完成后都要评审和确认。
2.2 确认过程：严格的追溯过程，后一阶段出现了问题要通过前一阶段的重新确认来解决，问题发现的越晚，解决问题的难度越大

               <br/> 
`
            },
            {
              title: '系统设计包含',
              answer: `<br/>
              模块设计、代码设计、输入输出设计、文件或数据库设计、可靠性设计。
               <br/> 
`
            },
            {
              title: '原型法的基本思想',
              answer: `<br/>
              1.在对用户需求的初步调查的基础上，快速构建一个可以运行的模型。 <br/> 
2.将原型提供给用户使用，并听取他们的意见。 <br/> 
3.修改原型，补充新的数据、模型及数据结构，形成新的模型。 <br/> 
4.多次迭代后，达到用户与开发者的完全沟通，消除各种误解，形成明确的系统定义和用户页面。 <br/> 
原型法是初期快速构建一个可运行的模型，然后对原型系统逐步求精，不断完善，得到最终的软件。 <br/> 

               <br/> 
               `
            },
            {
              title: '原型法产生的背景',
              answer: `<br/>
              1.并非所有的需求都能被预先定义。
               <br/> 
① 用户难以将需求都讲清楚
② 需求随着时间推移会不断改变
③ 开发人员对业务不熟悉
2.项目参与人员间存在沟通障碍
               <br/> 
3.有快速构建的工具
               <br/> 

               <br/> 
               `
            },
            {
              title: '原型法中的角色',
              answer: `<br/>
              1.用户/设计者
               <br/> 
2.系统建造者

               <br/> 
               `
            },
            {
              title: '原型法的特点',
              answer: `<br/>
              1.引入了迭代的概念。<br/>
2.自始至终强调用户的参与。<br/>
3.在需求分析、系统功能描述及系统实现方法等方面允许有较大的灵活性。<br/>
4.可以用来评价多种不同的设计方案。<br/>
5.可以用来建立系统的某个部分。<br/>
6.不排斥传统生命周期方法，和传统方法互补。<br/>

               <br/> 
               `
            },
            {
              title: '原型法的优点',
              answer: `<br/>
              1.可以处理模糊的需求，更好的进行定义需求。开发者和用户之间进行充分的通信。
2.原型系统可以用来当做培训环境。 <br/> 
3.可以给用户提供机会更改需求及系统设计。 <br/> 
4.可以低风险开发柔性较大的系统。 <br/> 
5.系统更易维护、用户体验更友好。 <br/> 
6.降低开发时间及开发费用。 <br/> 

               <br/> 
               `
            },
            {
              title: '原型法的缺点',
              answer: `<br/>
              1.容易产生‘模型效应’。以次当主，做出不切题的原型。<br/>
2.原型迭代不收敛于预先的开发目标。每次更新为了消除错误把次要部分越做越大，淹没了主体部分。<br/>
3.原型过快收敛于需求集合，而忽略一些基本点。<br/>
4.因为资源规划及管理较为困难，给随时更新文档带来麻烦。<br/>
5.长期在原型环境开发，容易忽略原型环境和真实环境的差异。<br/>

               <br/> 
               `
            },
            {
              title: '结构化方法的基本思想',
              answer: `<br/>
              1.自顶向下、逐步求精。<br/> 
2.采用模块化方法，将系统按功能拆分成多个模块。<br/> 
3.模块内部按顺序、分支、循环基本结构控制组成。<br/> 
4.应用子程序实现模块化。<br/> 

               `
            },
            {
              title: '结构化方法的两个阶段',
              answer: `<br/>
              1.结构化分析 <br/> 
主要任务是分析系统的功能、性能、目标和规模等需求，定义系统的逻辑模型 <br/> 
2.结构化设计 <br/> 
   主要任务是设计系统的模块结构、数据文件等，给出模块说明书和主要算法，为以后的编码进行算法和结构上的准备。 <br/> 

              
               `
            },
            {
              title: '结构化分析强调：',
              answer: `<br/>
              1.面向用户的观点。<br/> 
2.严格区分工作阶段。<br/> 
3.结构化、规模化，自顶向下进行。<br/> 
4.充分预料可能发生的变化。<br/> 
5.工作文件的标准化和文献化。<br/> 

               <br/> 
               `
            },
            {
              title: '结构化分析精髓：***',
              answer: `<br/>
              1.自顶向下逐步分解，将一个复杂问题进行拆分为若干个简单问题。
               <br/> 
2.抽象，透过表象看本质，找到通用问题的一般解法。
               <br/> 

               `
            },
            {
              title: '结构化分析的工具：***',
              answer: `<br/>
              1.数据流图（DFD）<br/> 
              
1.1 结构化分析的重要工具，是需求分析说明书中的重要组成部分。 <br/> 
1.2 四个部分组成 数据流、加工处理、数据存储、外部对象。 <br/> 
2.数据字典（DD）<br/> 

2.1 关于数据流图中数据元素（数据流，数据存储。数据项）集合的定义和说明。 <br/> 
2.2 三条类目： 数据流，数据文件（数据存储），数据项 <br/> 
3.加工说明<br/> 
3.1 数据字典的一部分，是对加工‘做什么’的描述。 <br/> 
3.2 一般包括加工名、编号、激发条件、加工逻辑、执行效率、优先级、输入输出等。 <br/> 

4.结构化语言<br/> 
4.1 介于计算机程序设计语言与自然语音之间。 <br/> 
4.2 不如计算机程序设计语言精确，但是简单明了，易于掌握和沟通。 <br/> 
4.3 避免了自然语言的二义性等问题。 <br/> 
4.4 适合作为需求分析的工具。 <br/> 
               <br/> 
               `
            },
            {
              title: '结构化设计的原则',
              answer: `<br/>
              1.模块化 <br/> 
2.抽象 <br/> 
3.信息的隐藏和信息局部化 <br/> 
4.一致性，完整性和确定性 <br/> 
               `
            },
            {
              title: '对象是什么',
              answer: `<br/>
              1.对象是一个封装和一个抽象。<br/> 
1.1 封装是对 对象属性及属性上专有的操作的封装。<br/> 
1.2 抽象是对问题空间的抽象，指问题空间类似事物一次或多次的出现。<br/> 
1.3 对象既包括属性，也包括作用于属性的行为。<br/> 
2.类：<br/> 
2.1 对一组对象的抽象。<br/> 
2.2 一个类可以生成多个不同的对象。<br/> 

              <br/> 
               `
            },
            {
              title: '面向对象三大特性',
              answer: `<br/>
              1.封装 <br/> 
2.继承 <br/> 
3.多态 <br/> 

               <br/> 
               `
            },
            {
              title: '类的组成',
              answer: `<br/>由名称、属性、操作 三个部分组成
               <br/> 
               `
            },
            {
              title: '属性的类型',
              answer: `<br/>单值属性、排他属性、多值属性
               <br/> 
               `
            },
            {
              title: '属性的可见性',
              answer: `<br/>公有的、私有的、保护的、

               <br/> 
               `
            },
            {
              title: '操作的可见性:',
              answer: `<br/>公有的、私有的、保护的、

               <br/> 
               `
            },
            {
              title: '类与类之间的关系',
              answer: `<br/>1.关联关系
2.聚合关系
3.继承关系
4.依赖关系
5.精化关系

               <br/> 
               `
            },
            {
              title: '构件的概念',
              answer: `<br/>一方定义规格说明，一方来实现，然后供给第三方使用
               <br/> 
               `
            },
            {
              title: '软件构件的概念',
              answer: `<br/>1.是可重用的用以构造系统的软件单元。<br/> 
2.一个构件在某种情况下可以作为独立的软件运行，在另一种情况下可以和其他构件一起构成新的系统。<br/> 
3.软件构件类似硬件的即插即用的集成电路的方式。<br/> 
4.构件和对象都是对现实世界的抽象描述，通过接口封装了可复用的代码实现。<br/> 

               <br/> 
               `
            },
            {
              title: '',
              answer: `<br/>
              1.概念层面上，对象描述客观世界实体，构件提供客观世界服务。
2.复用策略上，对象是通过继承实现复用，构件是通过合成实现复用。
3.技术手段上，构件通过对象技术而实现，对象按规定经过适当的接口包装后成为一个构件。，一个构件通常是多个对象的集合体
               <br/> 
               `
            },
            {
              title: '构件的分类  按复用方式区别',
              answer: `<br/>黑匣构件、白匣构件

               <br/> 
               `
            },
            {
              title: '按使用范围区别构件',
              answer: `<br/>通用构件、专用构件

               <br/> 
               `
            },
            {
              title: '按构件颗粒度区别',
              answer: `<br/>小型构件、中型构件、大型构件

               <br/> 
               `
            },
            {
              title: '按功能用途区别构件',
              answer: `<br/>系统构件、支撑构件、领域构件
               <br/> 
               `
            },
            {
              title: '结构区别构件',
              answer: `<br/>原子构件、组合构件
               <br/> 
               `
            },
            {
              title: '重用时的状态区别',
              answer: `<br/>动态构件、静态构件
               <br/> 
               `
            },
            {
              title: '构件的构造原则 ***',
              answer: `<br/>
              1.可重用性 <br/> 
2.可视化 <br/> 
3.提供领域构件对象的复用程度 <br/> 
4.构件的制作应该支持面向对象方法 <br/> 
5.构件的规模限制 <br/> 
              
               `
            },
            {
              title: '面向服务的产生',
              answer: `<br/>1.代码的重用
              <br/> 
2.对象的重用
              <br/> 
3.组件的重用
              <br/> 
4.服务的重用： 将应用程序以服务的方式提供给别人使用。
              <br/> 

              
               `
            },
            {
              title: '服务的核心',
              answer: `<br/>1.服务是封装的逻辑<br/> 
2.服务是交互的<br/> 
3.服务是特定的通信方式<br/> 

              
              
               `
            },
            {
              title: '服务模型中的三种基本角色',
              answer: `<br/>1.服务提供者<br/> 
2.服务代理<br/> 
3.服务请求者<br/> 

              
              
               `
            },
            {
              title: '敏捷开发法的特点',
              answer: `<br/>1.传统开发方法强调过程和工具，而敏捷开发法重视以人为本。<br/> 
2.敏捷开发法强调开发的产品是软件的本身。重点是放在尽快发布可工作的软件上。<br/> 
3.敏捷开发认为客户和开发者的关系是协同、而不是合约。<br/> 
4.敏捷开发认为变化是不可不免的，需要紧跟变化调整开发。<br/> 

              
              
               `
            },
            {
              title: '敏捷开发的原则',
              answer: `<br/>1.需要尽早的、持续的交付有价值的软件来让客户满意。 <br/> 
2.即使到了开发的后期，也要欢迎需求的改变。 <br/> 
3.经常性的交付可工作的软件。 <br/> 
4.整个开发期间，业务人员需要和开发人员在一起工作。 <br/> 
5.围绕被激励起来的个人构建项目。 <br/> 
6.在团队内部最高效的沟通就是面对面的交谈。 <br/> 

             
              
               `
            },
            {
              title: '极限编程（xp）',
              answer: `<br/>
              1.敏捷开发中最著名的一个。<br/>
2.由一系列简单却互相依赖的实践组成。<br/>
3.这些实践结合在一起形成了一个胜于部分结合的整体。<br/>
4.属于轻量开发中比较有影响的一种方法。<br/>
               `
            }
          ]
        }
      },
      mounted() {

        this.mixinList = this.list || []
      },
      watch: {
        acitveIndex(val) {
          this.answer = ''
        }
      },
      methods: {
        mixinListFn() {
          this.acitveIndex = 0,
            this.showAnswerList = []
          const list = this.list.map((v, i) => {
            return i
          })
          let arr = []
          while (list.length) {
            const i = Math.floor(Math.random() * list.length)
            arr.push(this.list[list[i]])
            list.splice(i, 1)
          }
          this.mixinList = arr
        }
      }
    }

    Vue.createApp(HelloVueApp).mount('#hello-vue')
  </script>
</body>

</html>
